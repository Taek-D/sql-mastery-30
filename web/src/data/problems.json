[
  {
    "day": 1,
    "title": "월별 신규 가입자 수",
    "difficulty": "basic",
    "database": "ecommerce",
    "context": "에이블리의 그로스팀에서 \"최근 6개월 월별 신규 가입자 추이\"를 요청했습니다. 마케팅 캠페인 효과를 분석하고, 어느 달에 신규 유입이 많았는지 파악하려 합니다.",
    "schema": [
      {
        "table": "users",
        "columns": [
          "user_id",
          "signup_date",
          "region",
          "user_segment"
        ]
      }
    ],
    "question": "2025년 1월부터 6월까지 각 월별 신규 가입자 수를 계산하세요.\n결과는 월별로 정렬되어야 합니다.",
    "hints": [
      "DATE_TRUNC() 함수로 날짜를 월 단위로 자를 수 있습니다",
      "GROUP BY로 월별로 그룹화",
      "COUNT(*)로 각 그룹의 사용자 수 계산"
    ],
    "answerQuery": "SELECT \n    strftime('%Y-%m-01', signup_date) AS signup_month,\n    COUNT(*) AS new_users\nFROM users\nWHERE signup_date >= '2025-01-01' \n  AND signup_date < '2025-07-01'\nGROUP BY strftime('%Y-%m-01', signup_date)\nORDER BY signup_month;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM users\n",
    "explanation": "왜 이 방법을 선택했는가? - `DATE_TRUNC('month', signup_date)`: 날짜를 월의 첫날로 변환 (예: 2025-01-15 → 2025-01-01) - `WHERE` 절로 먼저 필터링하면 GROUP BY 전에 불필요한 데이터 제거 가능 - `COUNT(*)`는 NULL이 아닌 모든 행을 세므로 안전 핵심 SQL 개념"
  },
  {
    "day": 2,
    "title": "상품 카테고리별 매출 Top 5",
    "difficulty": "basic",
    "database": "ecommerce",
    "context": "라프텔의 상품팀에서 \"어떤 카테고리가 가장 잘 팔리는가?\"를 분석하려 합니다. 카테고리별 총 매출을 계산하고, 상위 5개 카테고리를 찾아야 합니다.",
    "schema": [
      {
        "table": "products",
        "columns": [
          "product_id",
          "product_name",
          "category",
          "price"
        ]
      },
      {
        "table": "order_items",
        "columns": [
          "order_item_id",
          "order_id",
          "product_id",
          "quantity",
          "item_price"
        ]
      }
    ],
    "question": "2025년 전체 기간 동안 카테고리별 총 매출을 계산하고, 매출이 높은 상위 5개 카테고리를 찾으세요.",
    "hints": [
      "JOIN으로 products와 order_items 연결",
      "SUM(quantity * item_price)로 총 매출 계산",
      "ORDER BY ... DESC LIMIT 5로 상위 5개 추출"
    ],
    "answerQuery": "SELECT \n    p.category,\n    SUM(oi.quantity * oi.item_price) AS total_revenue\nFROM products p\nJOIN order_items oi ON p.product_id = oi.product_id\nJOIN orders o ON oi.order_id = o.order_id\nWHERE o.order_date >= '2025-01-01' \n  AND o.order_date < '2026-01-01'\n  AND o.status = 'completed'\nGROUP BY p.category\nORDER BY total_revenue DESC\nLIMIT 5;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM products\n",
    "explanation": "왜 이 방법을 선택했는가? - `JOIN`: products와 order_items를 연결해 카테고리 정보 가져오기 - `orders` 테이블 조인: 주문 날짜 필터링 및 완료된 주문만 집계 - `status = 'completed'`: 취소/대기 상태 주문 제외 - `SUM(quantity * item_price)`: 총 매출 = 수량 × 가격"
  },
  {
    "day": 3,
    "title": "재구매 고객 수",
    "difficulty": "basic",
    "database": "ecommerce",
    "context": "토스 커머스팀에서 \"고객 충성도\"를 측정하려 합니다. 2회 이상 구매한 고객(재구매 고객)의 수를 파악해 리텐션 전략을 수립하려 합니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "order_date",
          "total_amount",
          "status"
        ]
      }
    ],
    "question": "2025년 전체 기간 동안 2회 이상 주문한 고객의 수를 계산하세요.\n(status = 'completed'인 주문만 집계)",
    "hints": [
      "GROUP BY user_id로 고객별 주문 수 계산",
      "HAVING COUNT(*) >= 2로 2회 이상 필터링",
      "외부 쿼리에서 COUNT(*)로 고객 수 계산"
    ],
    "answerQuery": "SELECT COUNT(*) AS repeat_customers\nFROM (\n    SELECT user_id\n    FROM orders\n    WHERE order_date >= '2025-01-01' \n      AND order_date < '2026-01-01'\n      AND status = 'completed'\n    GROUP BY user_id\n    HAVING COUNT(*) >= 2\n) AS repeat_users;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "왜 이 방법을 선택했는가? - Subquery 사용: 먼저 재구매 고객 목록을 추출한 후 COUNT - `HAVING COUNT(*) >= 2`: GROUP BY 후 조건 필터링 - `status = 'completed'`: 취소/대기 주문 제외 핵심 SQL 개념"
  },
  {
    "day": 4,
    "title": "평균 주문 금액이 10만원 이상인 사용자",
    "difficulty": "basic",
    "database": "ecommerce",
    "context": "무신사의 VIP 고객 관리팀에서 \"고액 결제 고객\"을 식별하려 합니다. 평균 주문 금액이 10만원 이상인 고객에게 특별 할인 쿠폰을 발송할 예정입니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "order_date",
          "total_amount",
          "status"
        ]
      }
    ],
    "question": "2025년 전체 기간 동안 평균 주문 금액이 100,000원 이상인 사용자의 수를 계산하세요.\n(status = 'completed'인 주문만 집계)",
    "hints": [
      "Subquery로 사용자별 평균 주문 금액 계산",
      "AVG(total_amount) >= 100000 조건 적용",
      "외부 쿼리에서 사용자 수 COUNT"
    ],
    "answerQuery": "SELECT COUNT(*) AS high_value_customers\nFROM (\n    SELECT user_id\n    FROM orders\n    WHERE order_date >= '2025-01-01' \n      AND order_date < '2026-01-01'\n      AND status = 'completed'\n    GROUP BY user_id\n    HAVING AVG(total_amount) >= 100000\n) AS high_spenders;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - `AVG()` 집계 함수로 평균 계산 - `HAVING`으로 집계 결과 필터링 - Subquery 패턴 활용 Q1: CTE로 작성하면?"
  },
  {
    "day": 5,
    "title": "이번 달 가입자 중 구매 완료한 사용자 비율",
    "difficulty": "basic",
    "database": "ecommerce",
    "context": "쿠팡의 신규 가입자 전환율을 측정합니다. \"이번 달 가입한 사용자 중 실제로 구매까지 완료한 비율\"을 계산해 온보딩 효과를 평가합니다.",
    "schema": [
      {
        "table": "users",
        "columns": [
          "user_id",
          "signup_date"
        ]
      },
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "order_date",
          "status"
        ]
      }
    ],
    "question": "2025년 1월에 가입한 사용자 중 같은 달에 최소 1회 이상 구매(status='completed')한 사용자의 비율(%)을 계산하세요.",
    "hints": [
      "LEFT JOIN으로 가입자와 주문 연결",
      "COUNT(DISTINCT ...)로 구매 완료 사용자 수 계산",
      "비율 = (구매 사용자 / 전체 가입자) * 100"
    ],
    "answerQuery": "WITH jan_signups AS (\n    SELECT user_id\n    FROM users\n    WHERE signup_date >= '2025-01-01' \n      AND signup_date < '2025-02-01'\n),\njan_purchasers AS (\n    SELECT DISTINCT u.user_id\n    FROM jan_signups u\n    JOIN orders o ON u.user_id = o.user_id\n    WHERE o.order_date >= '2025-01-01' \n      AND o.order_date < '2025-02-01'\n      AND o.status = 'completed'\n)\nSELECT \n    COUNT(DISTINCT js.user_id) AS total_signups,\n    COUNT(DISTINCT jp.user_id) AS purchasers,\n    ROUND(100.0 * COUNT(DISTINCT jp.user_id) / COUNT(DISTINCT js.user_id), 2) AS conversion_rate_pct\nFROM jan_signups js\nLEFT JOIN jan_purchasers jp ON js.user_id = jp.user_id;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM users\n",
    "explanation": "핵심 개념 - CTE로 복잡한 로직 분리 - LEFT JOIN으로 전체 가입자 유지 - 비율 계산 시 `100.0 *` (소수점 계산) Q1: 더 간단한 방법은?"
  },
  {
    "day": 6,
    "title": "최근 30일 일별 주문 수 추이",
    "difficulty": "basic",
    "database": "ecommerce",
    "context": "배달의민족의 운영팀에서 \"최근 주문량 추이\"를 모니터링합니다. 일별 주문 수를 시각화하여 트래픽 패턴을 파악하려 합니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "order_date",
          "status"
        ]
      }
    ],
    "question": "2025년 1월 1일부터 1월 30일까지 일별 주문 수(status='completed')를 계산하세요.",
    "hints": [
      "DATE_TRUNC 또는 DATE로 날짜만 추출",
      "GROUP BY 날짜",
      "ORDER BY로 시간 순 정렬"
    ],
    "answerQuery": "SELECT \n    DATE(order_date) AS order_day,\n    COUNT(*) AS order_count\nFROM orders\nWHERE order_date >= '2025-01-01' \n  AND order_date < '2025-01-31'\n  AND status = 'completed'\nGROUP BY DATE(order_date)\nORDER BY order_day;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - `DATE()` 함수로 타임스탬프에서 날짜만 추출 - 일별 집계 패턴 Q1: 주문이 없는 날도 0으로 표시하려면? WITH RECURSIVE date_range AS ("
  },
  {
    "day": 7,
    "title": "구독 취소율 계산",
    "difficulty": "basic",
    "database": "subscription",
    "context": "넷플릭스의 retention 팀에서 \"이번 달 구독 취소율\"을 계산합니다. 월간 이탈률을 모니터링하여 서비스 개선 우선순위를 결정합니다.",
    "schema": [
      {
        "table": "subscriptions",
        "columns": [
          "subscription_id",
          "user_id",
          "start_date",
          "end_date",
          "status"
        ]
      }
    ],
    "question": "2025년 1월에 활성 상태였던 구독 중 취소(status='cancelled')된 구독의 비율(%)을 계산하세요.",
    "hints": [
      "1월 시작 시점 활성 구독 = start_date < 2025-02-01 AND (end_date IS NULL OR end_date >= 2025-01-01)",
      "1월 중 취소 = status = 'cancelled' AND end_date BETWEEN ...",
      "비율 = 취소 / 활성 * 100"
    ],
    "answerQuery": "WITH active_subs AS (\n    SELECT subscription_id\n    FROM subscriptions\n    WHERE start_date < '2025-02-01'\n      AND (end_date IS NULL OR end_date >= '2025-01-01')\n),\ncancelled_subs AS (\n    SELECT subscription_id\n    FROM subscriptions\n    WHERE status = 'cancelled'\n      AND end_date >= '2025-01-01'\n      AND end_date < '2025-02-01'\n)\nSELECT \n    COUNT(DISTINCT a.subscription_id) AS active_count,\n    COUNT(DISTINCT c.subscription_id) AS cancelled_count,\n    ROUND(100.0 * COUNT(DISTINCT c.subscription_id) / COUNT(DISTINCT a.subscription_id), 2) AS churn_rate_pct\nFROM active_subs a\nLEFT JOIN cancelled_subs c ON a.subscription_id = c.subscription_id;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM subscriptions\n",
    "explanation": "핵심 개념 - 활성 상태 정의 (NULL 처리) - 기간 필터링 - 비율 계산 Q1: 간단하게 한 번에 계산?"
  },
  {
    "day": 8,
    "title": "사용자별 총 구매 금액 Top 10",
    "difficulty": "basic",
    "database": "ecommerce",
    "context": "올리브영의 마케팅팀에서 \"최고 고객(Top Spenders)\"을 식별합니다. 총 구매 금액 상위 10명에게 VIP 혜택을 제공할 예정입니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "total_amount",
          "status"
        ]
      }
    ],
    "question": "2025년 전체 기간 동안 사용자별 총 구매 금액을 계산하고, 상위 10명을 찾으세요.",
    "hints": [],
    "answerQuery": "SELECT \n    user_id,\n    SUM(total_amount) AS total_spent\nFROM orders\nWHERE order_date >= '2025-01-01'\n  AND order_date < '2026-01-01'\n  AND status = 'completed'\nGROUP BY user_id\nORDER BY total_spent DESC\nLIMIT 10;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - SUM 집계 - ORDER BY DESC + LIMIT Q1: 사용자 이름도 함께 표시? SELECT"
  },
  {
    "day": 9,
    "title": "미구매 고객 수",
    "difficulty": "basic",
    "database": "ecommerce",
    "context": "당근마켓의 그로스팀에서 \"가입 후 한 번도 거래하지 않은 사용자\"를 파악합니다. 이들에게 첫 거래 유도 캠페인을 진행하려 합니다.",
    "schema": [
      {
        "table": "users",
        "columns": [
          "user_id",
          "signup_date"
        ]
      },
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "status"
        ]
      }
    ],
    "question": "2025년에 가입했지만 한 번도 구매(status='completed')하지 않은 사용자 수를 계산하세요.",
    "hints": [],
    "answerQuery": "SELECT COUNT(*) AS non_purchasers\nFROM users u\nLEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'\nWHERE u.signup_date >= '2025-01-01'\n  AND u.signup_date < '2026-01-01'\n  AND o.order_id IS NULL;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM users\n",
    "explanation": "핵심 개념 - LEFT JOIN + IS NULL 패턴 - \"존재하지 않는\" 데이터 찾기 Q1: NOT EXISTS 사용? SELECT COUNT(*) AS non_purchasers"
  },
  {
    "day": 10,
    "title": "주문당 평균 상품 개수",
    "difficulty": "basic",
    "database": "ecommerce",
    "context": "쿠팡의 물류팀에서 \"주문당 평균 상품 개수\"를 분석합니다. 포장 크기 최적화를 위해 이 지표를 활용합니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "status"
        ]
      },
      {
        "table": "order_items",
        "columns": [
          "order_item_id",
          "order_id",
          "quantity"
        ]
      }
    ],
    "question": "2025년 1월 완료된 주문(status='completed')의 주문당 평균 상품 개수를 계산하세요.",
    "hints": [],
    "answerQuery": "SELECT \n    ROUND(AVG(items_per_order), 2) AS avg_items_per_order\nFROM (\n    SELECT \n        o.order_id,\n        SUM(oi.quantity) AS items_per_order\n    FROM orders o\n    JOIN order_items oi ON o.order_id = oi.order_id\n    WHERE o.order_date >= '2025-01-01'\n      AND o.order_date < '2025-02-01'\n      AND o.status = 'completed'\n    GROUP BY o.order_id\n) AS order_summary;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - 집계 후 다시 집계 (주문별 SUM → 전체 AVG) - Subquery 패턴 Q1: 윈도우 함수로? WITH order_totals AS ("
  },
  {
    "day": 11,
    "title": "7일 Rolling MAU",
    "difficulty": "intermediate",
    "database": "subscription",
    "context": "라프텔의 데이터팀에서 \"7일 Rolling MAU (Monthly Active Users)\"를 계산합니다. 특정 날짜 기준 최근 7일간 활동한 순 사용자 수를 추적하여 서비스 건강도를 모니터링합니다.",
    "schema": [
      {
        "table": "events",
        "columns": [
          "event_id",
          "user_id",
          "event_date",
          "event_type"
        ]
      }
    ],
    "question": "2025년 1월 8일부터 1월 31일까지 각 날짜의 7일 Rolling MAU를 계산하세요.\n(각 날짜 기준 최근 7일간 활동한 고유 사용자 수)",
    "hints": [],
    "answerQuery": "SELECT \n    DATE(event_date) AS date,\n    COUNT(DISTINCT user_id) FILTER (\n        WHERE event_date >= DATE(event_date) - INTERVAL '6 days'\n          AND event_date <= DATE(event_date)\n    ) AS rolling_7day_mau\nFROM events\nWHERE event_date >= '2025-01-08'\n  AND event_date < '2025-02-01'\nGROUP BY DATE(event_date)\nORDER BY date;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM events\n",
    "explanation": "핵심 개념 - Rolling Window: 이동 시간 범위 - DISTINCT 중요: 같은 사용자가 여러 번 활동해도 1명 Q1: DAU/MAU 비율도 계산? WITH daily_active AS ("
  },
  {
    "day": 12,
    "title": "코호트별 D7/D30 리텐션율",
    "difficulty": "intermediate",
    "database": "subscription",
    "context": "토스의 그로스팀에서 \"가입 코호트별 리텐션율\"을 계산합니다. 특정 월에 가입한 사용자 중 7일 후, 30일 후에도 활동 중인 비율을 측정합니다.",
    "schema": [
      {
        "table": "users",
        "columns": [
          "user_id",
          "signup_date"
        ]
      },
      {
        "table": "events",
        "columns": [
          "event_id",
          "user_id",
          "event_date"
        ]
      }
    ],
    "question": "2025년 1월에 가입한 사용자의 D7 리텐션율(7일 후), D30 리텐션율(30일 후)을 계산하세요.",
    "hints": [],
    "answerQuery": "WITH jan_cohort AS (\n    SELECT user_id, signup_date\n    FROM users\n    WHERE signup_date >= '2025-01-01'\n      AND signup_date < '2025-02-01'\n),\nd7_active AS (\n    SELECT DISTINCT jc.user_id\n    FROM jan_cohort jc\n    JOIN events e ON jc.user_id = e.user_id\n    WHERE e.event_date >= date(jc.signup_date, '+7 days')\n      AND e.event_date < date(jc.signup_date, '+8 days')\n),\nd30_active AS (\n    SELECT DISTINCT jc.user_id\n    FROM jan_cohort jc\n    JOIN events e ON jc.user_id = e.user_id\n    WHERE e.event_date >= date(jc.signup_date, '+30 days')\n      AND e.event_date < date(jc.signup_date, '+31 days')\n)\nSELECT \n    COUNT(DISTINCT jc.user_id) AS total_users,\n    COUNT(DISTINCT d7.user_id) AS d7_retained,\n    COUNT(DISTINCT d30.user_id) AS d30_retained,\n    ROUND(100.0 * COUNT(DISTINCT d7.user_id) / COUNT(DISTINCT jc.user_id), 2) AS d7_retention_pct,\n    ROUND(100.0 * COUNT(DISTINCT d30.user_id) / COUNT(DISTINCT jc.user_id), 2) AS d30_retention_pct\nFROM jan_cohort jc\nLEFT JOIN d7_active d7 ON jc.user_id = d7.user_id\nLEFT JOIN d30_active d30 ON jc.user_id = d30.user_id;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM users\n",
    "explanation": "핵심 개념 - 코호트 분석: 같은 시기 가입자 그룹 - Self JOIN: 가입일 기준 N일 후 계산 - 리텐션 = (N일 후 활동자 / 전체) * 100"
  },
  {
    "day": 13,
    "title": "상품별 누적 매출",
    "difficulty": "intermediate",
    "database": "ecommerce",
    "context": "에이블리의 PM이 \"이번 달 상품별 누적 매출 그래프\"를 요청했습니다. 일자별 매출을 누적해서 \"언제 목표 금액에 도달하는가\" 예측하려 합니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "product_id",
          "order_date",
          "total_amount"
        ]
      },
      {
        "table": "order_items",
        "columns": [
          "order_item_id",
          "order_id",
          "product_id",
          "quantity",
          "item_price"
        ]
      }
    ],
    "question": "2025년 1월 각 상품의 일자별 누적 매출을 계산하세요.",
    "hints": [],
    "answerQuery": "WITH daily_sales AS (\n    SELECT \n        oi.product_id,\n        DATE(o.order_date) AS sale_date,\n        SUM(oi.quantity * oi.item_price) AS daily_revenue\n    FROM orders o\n    JOIN order_items oi ON o.order_id = oi.order_id\n    WHERE o.order_date >= '2025-01-01'\n      AND o.order_date < '2025-02-01'\n      AND o.status = 'completed'\n    GROUP BY oi.product_id, DATE(o.order_date)\n)\nSELECT \n    product_id,\n    sale_date,\n    daily_revenue,\n    SUM(daily_revenue) OVER (\n        PARTITION BY product_id \n        ORDER BY sale_date\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ) AS cumulative_revenue\nFROM daily_sales\nORDER BY product_id, sale_date;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - Window Function: `SUM() OVER ()` - `PARTITION BY`: 상품별로 분리 - `ORDER BY`: 날짜 순 정렬 - `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`: 누적 범위"
  },
  {
    "day": 14,
    "title": "사용자별 첫 구매 후 재구매까지 기간",
    "difficulty": "intermediate",
    "database": "ecommerce",
    "context": "쿠팡의 리텐션팀에서 \"첫 구매 후 재구매까지 걸리는 시간\"을 분석합니다. 이 지표로 고객 충성도와 재구매 유도 시점을 파악합니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "order_date",
          "status"
        ]
      }
    ],
    "question": "각 사용자의 첫 구매일과 두 번째 구매일 사이의 일수를 계산하세요.\n(2회 이상 구매한 사용자만 포함)",
    "hints": [],
    "answerQuery": "WITH ordered_purchases AS (\n    SELECT \n        user_id,\n        order_date,\n        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY order_date) AS purchase_number\n    FROM orders\n    WHERE status = 'completed'\n),\nfirst_two AS (\n    SELECT \n        user_id,\n        MAX(CASE WHEN purchase_number = 1 THEN order_date END) AS first_purchase,\n        MAX(CASE WHEN purchase_number = 2 THEN order_date END) AS second_purchase\n    FROM ordered_purchases\n    WHERE purchase_number IN (1, 2)\n    GROUP BY user_id\n)\nSELECT \n    user_id,\n    first_purchase,\n    second_purchase,\n    second_purchase - first_purchase AS days_to_repurchase\nFROM first_two\nWHERE second_purchase IS NOT NULL\nORDER BY days_to_repurchase;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - `ROW_NUMBER()`: 순서 매기기 - `LAG()/LEAD()`: 이전/다음 행 값 가져오기 - CASE WHEN으로 피벗"
  },
  {
    "day": 15,
    "title": "카테고리별 매출 Top 3 상품",
    "difficulty": "intermediate",
    "database": "ecommerce",
    "context": "당근마켓의 카테고리별 \"베스트셀러 3개\"를 찾습니다. 각 카테고리에서 가장 잘 팔리는 상품을 프로모션에 활용합니다.",
    "schema": [
      {
        "table": "products",
        "columns": [
          "product_id",
          "product_name",
          "category"
        ]
      },
      {
        "table": "order_items",
        "columns": [
          "order_item_id",
          "product_id",
          "quantity",
          "item_price"
        ]
      }
    ],
    "question": "각 카테고리별 매출 상위 3개 상품과 매출액을 출력하세요.",
    "hints": [],
    "answerQuery": "WITH product_sales AS (\n    SELECT \n        p.category,\n        p.product_id,\n        p.product_name,\n        SUM(oi.quantity * oi.item_price) AS total_revenue,\n        ROW_NUMBER() OVER (\n            PARTITION BY p.category \n            ORDER BY SUM(oi.quantity * oi.item_price) DESC\n        ) AS rank_in_category\n    FROM products p\n    JOIN order_items oi ON p.product_id = oi.product_id\n    GROUP BY p.category, p.product_id, p.product_name\n)\nSELECT \n    category,\n    product_id,\n    product_name,\n    total_revenue,\n    rank_in_category\nFROM product_sales\nWHERE rank_in_category <= 3\nORDER BY category, rank_in_category;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM products\n",
    "explanation": "핵심 개념 - `ROW_NUMBER()`: 중복 없이 순위 - `RANK()`: 동점 시 같은 순위 - `DENSE_RANK()`: 동점 후 순위 건너뛰지 않음 Q1: RANK() 사용 시 차이?"
  },
  {
    "day": 16,
    "title": "전월 대비 매출 증감률",
    "difficulty": "intermediate",
    "database": "ecommerce",
    "context": "토스 커머스의 경영진이 \"월별 매출 성장률\"을 요청했습니다. 전월 대비 매출이 얼마나 증가했는지 추적하여 성장 흐름을 파악합니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "order_date",
          "total_amount",
          "status"
        ]
      }
    ],
    "question": "2025년 각 월의 총 매출과 전월 대비 증감률(%)을 계산하세요.",
    "hints": [],
    "answerQuery": "WITH monthly_revenue AS (\n    SELECT \n        strftime('%Y-%m-01', order_date) AS month,\n        SUM(total_amount) AS revenue\n    FROM orders\n    WHERE order_date >= '2025-01-01'\n      AND order_date < '2026-01-01'\n      AND status = 'completed'\n    GROUP BY strftime('%Y-%m-01', order_date)\n)\nSELECT \n    month,\n    revenue AS current_revenue,\n    LAG(revenue) OVER (ORDER BY month) AS previous_revenue,\n    ROUND(\n        100.0 * (revenue - LAG(revenue) OVER (ORDER BY month)) \n        / NULLIF(LAG(revenue) OVER (ORDER BY month), 0), \n        2\n    ) AS growth_rate_pct\nFROM monthly_revenue\nORDER BY month;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - `LAG()`: 이전 행 값 참조 - `NULLIF()`: 0으로 나누기 방지 - 증감률 = (현재 - 이전) / 이전 × 100 Q1: 전년 동월 대비는?"
  },
  {
    "day": 17,
    "title": "구매 전환 퍼널 분석",
    "difficulty": "intermediate",
    "database": "subscription",
    "context": "쿠팡의 CX팀에서 \"회원가입 → 첫 구매까지의 전환율\"을 분석합니다. 어느 단계에서 이탈이 많은지 파악하여 개선점을 찾습니다.",
    "schema": [
      {
        "table": "users",
        "columns": [
          "user_id",
          "signup_date"
        ]
      },
      {
        "table": "events",
        "columns": [
          "event_id",
          "user_id",
          "event_date",
          "event_type"
        ]
      },
      {
        "table": "event_type",
        "columns": [
          "'signup'",
          "'product_view'",
          "'add_to_cart'",
          "'checkout'",
          "'purchase'"
        ]
      }
    ],
    "question": "2025년 1월 가입 사용자의 각 퍼널 단계별 전환율을 계산하세요.\n(signup → product_view → add_to_cart → checkout → purchase)",
    "hints": [],
    "answerQuery": "WITH jan_users AS (\n    SELECT user_id\n    FROM users\n    WHERE signup_date >= '2025-01-01'\n      AND signup_date < '2025-02-01'\n),\nfunnel_stages AS (\n    SELECT \n        'signup' AS stage,\n        COUNT(DISTINCT ju.user_id) AS users,\n        1 AS step_order\n    FROM jan_users ju\n    \n    UNION ALL\n    \n    SELECT \n        'product_view',\n        COUNT(DISTINCT e.user_id),\n        2\n    FROM jan_users ju\n    JOIN events e ON ju.user_id = e.user_id \n        AND e.event_type = 'product_view'\n        AND e.event_date >= '2025-01-01'\n    \n    UNION ALL\n    \n    SELECT \n        'add_to_cart',\n        COUNT(DISTINCT e.user_id),\n        3\n    FROM jan_users ju\n    JOIN events e ON ju.user_id = e.user_id \n        AND e.event_type = 'add_to_cart'\n        AND e.event_date >= '2025-01-01'\n    \n    UNION ALL\n    \n    SELECT \n        'checkout',\n        COUNT(DISTINCT e.user_id),\n        4\n    FROM jan_users ju\n    JOIN events e ON ju.user_id = e.user_id \n        AND e.event_type = 'checkout'\n        AND e.event_date >= '2025-01-01'\n    \n    UNION ALL\n    \n    SELECT \n        'purchase',\n        COUNT(DISTINCT e.user_id),\n        5\n    FROM jan_users ju\n    JOIN events e ON ju.user_id = e.user_id \n        AND e.event_type = 'purchase'\n        AND e.event_date >= '2025-01-01'\n)\nSELECT \n    stage,\n    users,\n    ROUND(100.0 * users / FIRST_VALUE(users) OVER (ORDER BY step_order), 2) AS conversion_from_signup,\n    ROUND(100.0 * users / LAG(users) OVER (ORDER BY step_order), 2) AS conversion_from_previous\nFROM funnel_stages\nORDER BY step_order;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM users\n",
    "explanation": "핵심 개념 - Funnel Analysis: 단계별 사용자 이탈 추적 - `FIRST_VALUE()`: 첫 단계 기준 전환율 - `LAG()`: 이전 단계 기준 전환율 Q1: 각 단계별 평균 소요 시간은?"
  },
  {
    "day": 18,
    "title": "사용자별 구매 주기 계산",
    "difficulty": "intermediate",
    "database": "ecommerce",
    "context": "마켓컬리의 CRM팀에서 \"고객별 평균 구매 주기\"를 분석합니다. 재구매 시기를 예측하여 맞춤형 프로모션을 발송하려 합니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "order_date",
          "status"
        ]
      }
    ],
    "question": "3회 이상 구매한 사용자의 평균 구매 주기(일)를 계산하세요.",
    "hints": [],
    "answerQuery": "WITH user_orders AS (\n    SELECT \n        user_id,\n        order_date,\n        LEAD(order_date) OVER (PARTITION BY user_id ORDER BY order_date) AS next_order_date\n    FROM orders\n    WHERE status = 'completed'\n),\npurchase_intervals AS (\n    SELECT \n        user_id,\n        next_order_date - order_date AS days_between_orders\n    FROM user_orders\n    WHERE next_order_date IS NOT NULL\n),\nuser_stats AS (\n    SELECT \n        user_id,\n        COUNT(*) AS purchase_count,\n        AVG(days_between_orders) AS avg_purchase_cycle\n    FROM purchase_intervals\n    GROUP BY user_id\n    HAVING COUNT(*) >= 2  -- 3회 구매 = 2개 간격\n)\nSELECT \n    user_id,\n    purchase_count + 1 AS total_purchases,  -- 간격 개수 + 1\n    ROUND(avg_purchase_cycle, 1) AS avg_days_between_purchases\nFROM user_stats\nORDER BY avg_purchase_cycle;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - `LEAD()`: 다음 행 날짜 가져오기 - 날짜 빼기: PostgreSQL은 자동으로 일 수 계산 - N회 구매 = (N-1)개의 간격 Q1: 구매 주기 분포는?"
  },
  {
    "day": 19,
    "title": "월별 구독자 순증 계산",
    "difficulty": "intermediate",
    "database": "subscription",
    "context": "넷플릭스의 그로스팀에서 \"월별 구독자 순증\"을 계산합니다. 신규 가입자 - 이탈자 = 순증을 추적하여 성장 추이를 파악합니다.",
    "schema": [
      {
        "table": "subscriptions",
        "columns": [
          "subscription_id",
          "user_id",
          "start_date",
          "end_date",
          "status"
        ]
      },
      {
        "table": "status",
        "columns": [
          "'active'",
          "'cancelled'",
          "'expired'"
        ]
      }
    ],
    "question": "2025년 각 월의 신규 가입자, 해지자, 순증을 계산하세요.",
    "hints": [],
    "answerQuery": "WITH monthly_new AS (\n    SELECT \n        strftime('%Y-%m-01', start_date) AS month,\n        COUNT(*) AS new_subscriptions\n    FROM subscriptions\n    WHERE start_date >= '2025-01-01'\n      AND start_date < '2026-01-01'\n    GROUP BY strftime('%Y-%m-01', start_date)\n),\nmonthly_churn AS (\n    SELECT \n        strftime('%Y-%m-01', end_date) AS month,\n        COUNT(*) AS churned_subscriptions\n    FROM subscriptions\n    WHERE end_date >= '2025-01-01'\n      AND end_date < '2026-01-01'\n      AND status IN ('cancelled', 'expired')\n    GROUP BY strftime('%Y-%m-01', end_date)\n)\nSELECT \n    COALESCE(mn.month, mc.month) AS month,\n    COALESCE(mn.new_subscriptions, 0) AS new_subs,\n    COALESCE(mc.churned_subscriptions, 0) AS churned_subs,\n    COALESCE(mn.new_subscriptions, 0) - COALESCE(mc.churned_subscriptions, 0) AS net_growth\nFROM monthly_new mn\nFULL OUTER JOIN monthly_churn mc ON mn.month = mc.month\nORDER BY month;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM subscriptions\n",
    "explanation": "핵심 개념 - `FULL OUTER JOIN`: 신규/해지 모두 포함 - `COALESCE()`: NULL을 0으로 변환 - 순증 = 신규 - 해지 Q1: 월말 누적 구독자 수는?"
  },
  {
    "day": 20,
    "title": "상품별 재고 회전율",
    "difficulty": "intermediate",
    "database": "ecommerce",
    "context": "쿠팡의 물류팀에서 \"상품별 재고 회전율\"을 계산합니다. 판매 속도가 빠른 상품을 파악하여 재고 관리를 최적화합니다.",
    "schema": [
      {
        "table": "products",
        "columns": [
          "product_id",
          "product_name",
          "category"
        ]
      },
      {
        "table": "inventory",
        "columns": [
          "product_id",
          "stock_quantity",
          "last_updated"
        ]
      },
      {
        "table": "order_items",
        "columns": [
          "order_item_id",
          "product_id",
          "quantity",
          "order_date"
        ]
      }
    ],
    "question": "2025년 1월 각 상품의 판매량, 평균 재고, 재고 회전율을 계산하세요.\n재고 회전율 = 판매량 / 평균 재고",
    "hints": [],
    "answerQuery": "WITH jan_sales AS (\n    SELECT \n        product_id,\n        SUM(quantity) AS total_sold\n    FROM order_items\n    WHERE order_date >= '2025-01-01'\n      AND order_date < '2025-02-01'\n    GROUP BY product_id\n),\navg_inventory AS (\n    SELECT \n        product_id,\n        AVG(stock_quantity) AS avg_stock\n    FROM inventory\n    WHERE last_updated >= '2025-01-01'\n      AND last_updated < '2025-02-01'\n    GROUP BY product_id\n)\nSELECT \n    p.product_id,\n    p.product_name,\n    p.category,\n    COALESCE(js.total_sold, 0) AS total_sold,\n    COALESCE(ai.avg_stock, 0) AS avg_stock,\n    CASE \n        WHEN ai.avg_stock > 0 THEN \n            ROUND(COALESCE(js.total_sold, 0)::NUMERIC / ai.avg_stock, 2)\n        ELSE 0\n    END AS inventory_turnover_ratio\nFROM products p\nLEFT JOIN jan_sales js ON p.product_id = js.product_id\nLEFT JOIN avg_inventory ai ON p.product_id = ai.product_id\nWHERE js.total_sold > 0 OR ai.avg_stock > 0\nORDER BY inventory_turnover_ratio DESC;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM products\n",
    "explanation": "핵심 개념 - 재고 회전율: 판매 속도 지표 - 높을수록 빠르게 판매됨 - `CASE WHEN`: 0으로 나누기 방지 Q1: 카테고리별 평균 회전율?"
  },
  {
    "day": 21,
    "title": "RFM 세그먼트 분류",
    "difficulty": "advanced",
    "database": "ecommerce",
    "context": "토스 커머스의 CRM팀에서 \"RFM 분석\"을 수행합니다. 고객을 Recency(최근성), Frequency(빈도), Monetary(금액) 기준으로 세분화하여 맞춤형 마케팅을 진행합니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "order_date",
          "total_amount",
          "status"
        ]
      }
    ],
    "question": "2025년 고객을 RFM 점수로 분류하세요.\n- Recency: 최근 구매일 (낮을수록 좋음, 1~5점)\n- Frequency: 구매 횟수 (높을수록 좋음, 1~5점)\n- Monetary: 총 구매액 (높을수록 좋음, 1~5점)",
    "hints": [],
    "answerQuery": "WITH user_metrics AS (\n    SELECT \n        user_id,\n        MAX(order_date) AS last_order_date,\n        COUNT(*) AS purchase_frequency,\n        SUM(total_amount) AS total_spent\n    FROM orders\n    WHERE order_date >= '2025-01-01'\n      AND order_date < '2026-01-01'\n      AND status = 'completed'\n    GROUP BY user_id\n),\nrfm_scores AS (\n    SELECT \n        user_id,\n        last_order_date,\n        purchase_frequency,\n        total_spent,\n        -- Recency: 최근일수록 높은 점수 (역순)\n        NTILE(5) OVER (ORDER BY last_order_date DESC) AS r_score,\n        -- Frequency: 많을수록 높은 점수\n        NTILE(5) OVER (ORDER BY purchase_frequency) AS f_score,\n        -- Monetary: 클수록 높은 점수\n        NTILE(5) OVER (ORDER BY total_spent) AS m_score\n    FROM user_metrics\n)\nSELECT \n    user_id,\n    last_order_date,\n    purchase_frequency,\n    total_spent,\n    r_score,\n    f_score,\n    m_score,\n    CONCAT(r_score, f_score, m_score) AS rfm_segment,\n    CASE \n        WHEN r_score >= 4 AND f_score >= 4 AND m_score >= 4 THEN 'Champions'\n        WHEN r_score >= 3 AND f_score >= 3 THEN 'Loyal Customers'\n        WHEN r_score >= 4 THEN 'Recent Customers'\n        WHEN r_score <= 2 AND f_score >= 3 THEN 'At Risk'\n        WHEN r_score <= 2 AND f_score <= 2 THEN 'Lost'\n        ELSE 'Others'\n    END AS customer_segment\nFROM rfm_scores\nORDER BY r_score DESC, f_score DESC, m_score DESC;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - `NTILE(5)`: 5개 그룹으로 분할 (1~5점) - RFM 555 = 최상위 고객 - RFM 111 = 이탈 위험 고객 Q1: 세그먼트별 고객 수?"
  },
  {
    "day": 22,
    "title": "일별 활성 사용자 중앙값",
    "difficulty": "intermediate",
    "database": "subscription",
    "context": "라프텔의 데이터팀에서 \"일별 활성 사용자의 중앙값\"을 계산합니다. 평균은 이상치에 민감하므로 중앙값으로 대표값을 파악합니다.",
    "schema": [
      {
        "table": "events",
        "columns": [
          "event_id",
          "user_id",
          "event_date"
        ]
      }
    ],
    "question": "2025년 1월 각 날짜의 활성 사용자 수 중앙값을 계산하세요.",
    "hints": [],
    "answerQuery": "WITH daily_active_users AS (\n    SELECT \n        DATE(event_date) AS day,\n        COUNT(DISTINCT user_id) AS dau\n    FROM events\n    WHERE event_date >= '2025-01-01'\n      AND event_date < '2025-02-01'\n    GROUP BY DATE(event_date)\n)\nSELECT \n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY dau) AS median_dau,\n    AVG(dau) AS mean_dau,\n    MIN(dau) AS min_dau,\n    MAX(dau) AS max_dau\nFROM daily_active_users;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM events\n",
    "explanation": "핵심 개념 - `PERCENTILE_CONT(0.5)`: 연속형 중앙값 - `PERCENTILE_DISC(0.5)`: 이산형 중앙값 (실제 존재하는 값) - `WITHIN GROUP`: 정렬 기준 Q1: 75th percentile (상위 25%)?"
  },
  {
    "day": 23,
    "title": "채널별 ROAS 계산",
    "difficulty": "intermediate",
    "database": "ecommerce",
    "context": "에이블리의 퍼포먼스 마케팅팀에서 \"채널별 ROAS (Return on Ad Spend)\"를 계산합니다. 광고비 대비 매출을 측정하여 효율적인 채널에 예산을 집중합니다.",
    "schema": [
      {
        "table": "marketing_spend",
        "columns": [
          "channel",
          "date",
          "spend_amount"
        ]
      },
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "order_date",
          "total_amount",
          "channel"
        ]
      }
    ],
    "question": "2025년 1월 각 마케팅 채널의 총 광고비, 총 매출, ROAS를 계산하세요.\nROAS = 매출 / 광고비",
    "hints": [],
    "answerQuery": "WITH channel_spend AS (\n    SELECT \n        channel,\n        SUM(spend_amount) AS total_spend\n    FROM marketing_spend\n    WHERE date >= '2025-01-01'\n      AND date < '2025-02-01'\n    GROUP BY channel\n),\nchannel_revenue AS (\n    SELECT \n        channel,\n        SUM(total_amount) AS total_revenue\n    FROM orders\n    WHERE order_date >= '2025-01-01'\n      AND order_date < '2025-02-01'\n      AND status = 'completed'\n    GROUP BY channel\n)\nSELECT \n    COALESCE(cs.channel, cr.channel) AS channel,\n    COALESCE(cs.total_spend, 0) AS ad_spend,\n    COALESCE(cr.total_revenue, 0) AS revenue,\n    CASE \n        WHEN cs.total_spend > 0 THEN \n            ROUND(cr.total_revenue / cs.total_spend, 2)\n        ELSE 0\n    END AS roas,\n    COALESCE(cr.total_revenue, 0) - COALESCE(cs.total_spend, 0) AS profit\nFROM channel_spend cs\nFULL OUTER JOIN channel_revenue cr ON cs.channel = cr.channel\nORDER BY roas DESC;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM marketing_spend\n",
    "explanation": "핵심 개념 - ROAS = 광고 수익률 - ROAS > 1: 수익 - ROAS < 1: 손실 - `FULL OUTER JOIN`: 광고비만 있거나 매출만 있는 경우 포함"
  },
  {
    "day": 24,
    "title": "사용자별 첫/마지막 활동 간격",
    "difficulty": "intermediate",
    "database": "subscription",
    "context": "넷플릭스의 리텐션팀에서 \"사용자별 활동 기간\"을 분석합니다. 첫 활동부터 마지막 활동까지의 기간으로 사용자의 생애주기를 파악합니다.",
    "schema": [
      {
        "table": "events",
        "columns": [
          "event_id",
          "user_id",
          "event_date",
          "event_type"
        ]
      }
    ],
    "question": "각 사용자의 첫 활동일, 마지막 활동일, 활동 기간(일)을 계산하세요.\n(최소 2회 이상 활동한 사용자만 포함)",
    "hints": [],
    "answerQuery": "WITH user_activity AS (\n    SELECT \n        user_id,\n        MIN(event_date) AS first_activity,\n        MAX(event_date) AS last_activity,\n        COUNT(*) AS total_events\n    FROM events\n    GROUP BY user_id\n    HAVING COUNT(DISTINCT DATE(event_date)) >= 2  -- 최소 2일 활동\n)\nSELECT \n    user_id,\n    first_activity,\n    last_activity,\n    last_activity - first_activity AS active_days,\n    total_events,\n    ROUND(CAST(total_events AS REAL) / NULLIF(last_activity - first_activity, 0), 2) AS events_per_day\nFROM user_activity\nORDER BY active_days DESC;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM events\n",
    "explanation": "핵심 개념 - `MIN()/MAX()`: 첫/마지막 값 - 날짜 빼기: 일 수 계산 - 활동 밀도 = 이벤트 수 / 활동 기간 Q1: 활동 기간별 사용자 분포?"
  },
  {
    "day": 25,
    "title": "Self JOIN으로 상품 추천 쌍 찾기",
    "difficulty": "advanced",
    "database": "ecommerce",
    "context": "쿠팡의 추천팀에서 \"함께 구매한 상품 쌍\"을 찾습니다. 같은 주문에 포함된 상품 조합을 분석하여 \"이 상품과 함께 구매한 상품\" 추천 로직에 활용합니다.",
    "schema": [
      {
        "table": "order_items",
        "columns": [
          "order_item_id",
          "order_id",
          "product_id"
        ]
      },
      {
        "table": "products",
        "columns": [
          "product_id",
          "product_name"
        ]
      }
    ],
    "question": "2025년 1월 같은 주문에 함께 포함된 상품 쌍을 빈도 높은 순으로 출력하세요.\n(같은 상품끼리 쌍은 제외)",
    "hints": [],
    "answerQuery": "WITH jan_orders AS (\n    SELECT DISTINCT oi.order_id, oi.product_id\n    FROM order_items oi\n    JOIN orders o ON oi.order_id = o.order_id\n    WHERE o.order_date >= '2025-01-01'\n      AND o.order_date < '2025-02-01'\n      AND o.status = 'completed'\n)\nSELECT \n    p1.product_name AS product_a,\n    p2.product_name AS product_b,\n    COUNT(*) AS co_purchase_count\nFROM jan_orders jo1\nJOIN jan_orders jo2 \n    ON jo1.order_id = jo2.order_id\n    AND jo1.product_id < jo2.product_id  -- 중복 제거 (A-B, B-A)\nJOIN products p1 ON jo1.product_id = p1.product_id\nJOIN products p2 ON jo2.product_id = p2.product_id\nGROUP BY p1.product_name, p2.product_name\nHAVING COUNT(*) >= 5  -- 최소 5회 이상\nORDER BY co_purchase_count DESC\nLIMIT 20;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM order_items\n",
    "explanation": "핵심 개념 - Self JOIN: 같은 테이블을 두 번 사용 - `product_id < product_id`: 중복 제거 - (1, 2)와 (2, 1)을 동일하게 취급 - Market Basket Analysis 기초"
  },
  {
    "day": 26,
    "title": "Recursive CTE로 조직도 계층 구조 조회",
    "difficulty": "advanced",
    "database": "ecommerce",
    "context": "카카오의 HR팀에서 \"조직도 계층 구조\"를 조회합니다. 특정 임원 아래의 모든 직원을 계층별로 조회하여 보고 체계를 파악합니다.",
    "schema": [
      {
        "table": "employees",
        "columns": [
          "employee_id",
          "employee_name",
          "manager_id",
          "position"
        ]
      }
    ],
    "question": "CEO (manager_id = NULL)부터 시작하여 전체 조직의 계층 구조를 조회하세요.\n각 직원의 레벨과 경로를 표시하세요.",
    "hints": [],
    "answerQuery": "WITH RECURSIVE org_chart AS (\n    -- 앵커: CEO (최상위)\n    SELECT \n        employee_id,\n        employee_name,\n        manager_id,\n        position,\n        1 AS level,\n        ARRAY[employee_id] AS path,\n        employee_name AS full_path\n    FROM employees\n    WHERE manager_id IS NULL\n    \n    UNION ALL\n    \n    -- 재귀: 하위 직원\n    SELECT \n        e.employee_id,\n        e.employee_name,\n        e.manager_id,\n        e.position,\n        oc.level + 1,\n        oc.path || e.employee_id,\n        oc.full_path || ' > ' || e.employee_name\n    FROM employees e\n    JOIN org_chart oc ON e.manager_id = oc.employee_id\n)\nSELECT \n    employee_id,\n    REPEAT('  ', level - 1) || employee_name AS hierarchy_display,\n    position,\n    level,\n    full_path\nFROM org_chart\nORDER BY path;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM employees\n",
    "explanation": "핵심 개념 - `RECURSIVE CTE`: 재귀 쿼리 - 앵커(Anchor): 시작점 (CEO) - 재귀(Recursive): 반복 로직 - `ARRAY[]`: 경로 추적"
  },
  {
    "day": 27,
    "title": "월별 신규/기존 사용자 매출 분해",
    "difficulty": "advanced",
    "database": "ecommerce",
    "context": "토스 커머스의 데이터팀에서 \"성장 회계(Growth Accounting)\"를 수행합니다. 월별 매출을 신규 고객, 기존 고객(재구매), 이탈로 분해하여 성장 원인을 파악합니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "order_date",
          "total_amount",
          "status"
        ]
      }
    ],
    "question": "2025년 각 월의 매출을:\n- 신규 고객 매출\n- 기존 고객 재구매 매출\n- 이탈 고객 매출 (전월 구매했으나 당월 미구매)\n로 분해하세요.",
    "hints": [],
    "answerQuery": "WITH monthly_users AS (\n    SELECT \n        strftime('%Y-%m-01', order_date) AS month,\n        user_id,\n        SUM(total_amount) AS user_revenue,\n        MIN(order_date) AS first_order_date\n    FROM orders\n    WHERE order_date >= '2025-01-01'\n      AND order_date < '2026-01-01'\n      AND status = 'completed'\n    GROUP BY strftime('%Y-%m-01', order_date), user_id\n),\nuser_classification AS (\n    SELECT \n        mu.month,\n        mu.user_id,\n        mu.user_revenue,\n        CASE \n            WHEN strftime('%Y-%m-01', mu.first_order_date) = mu.month THEN 'new'\n            ELSE 'returning'\n        END AS user_type\n    FROM monthly_users mu\n),\nprevious_month_users AS (\n    SELECT DISTINCT \n        strftime('%Y-%m-01', order_date) + INTERVAL '1 month' AS next_month,\n        user_id\n    FROM orders\n    WHERE status = 'completed'\n),\nchurned_revenue AS (\n    SELECT \n        pmu.next_month AS month,\n        COALESCE(SUM(o_prev.total_amount), 0) AS churned_amount\n    FROM previous_month_users pmu\n    LEFT JOIN monthly_users mu \n        ON pmu.user_id = mu.user_id \n        AND pmu.next_month = mu.month\n    LEFT JOIN orders o_prev \n        ON pmu.user_id = o_prev.user_id\n        AND strftime('%Y-%m-01', o_prev.order_date) = date(pmu.next_month, '-1 months')\n        AND o_prev.status = 'completed'\n    WHERE mu.user_id IS NULL  -- 당월 구매하지 않음\n    GROUP BY pmu.next_month\n)\nSELECT \n    uc.month,\n    SUM(CASE WHEN uc.user_type = 'new' THEN uc.user_revenue ELSE 0 END) AS new_customer_revenue,\n    SUM(CASE WHEN uc.user_type = 'returning' THEN uc.user_revenue ELSE 0 END) AS returning_customer_revenue,\n    COALESCE(cr.churned_amount, 0) AS churned_revenue,\n    SUM(uc.user_revenue) AS total_revenue\nFROM user_classification uc\nLEFT JOIN churned_revenue cr ON uc.month = cr.month\nGROUP BY uc.month, cr.churned_amount\nORDER BY uc.month;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - Growth Accounting: 성장 분해 - 신규 = 당월 첫 구매 - 기존 = 이전 구매 이력 있음 - 이탈 = 전월 구매했으나 당월 미구매"
  },
  {
    "day": 28,
    "title": "Cohort Retention Table (코호트 리텐션 테이블)",
    "difficulty": "advanced",
    "database": "subscription",
    "context": "넷플릭스의 그로스팀에서 \"월별 가입 코호트의 리텐션 매트릭스\"를 생성합니다. 각 가입 월별로 M0, M1, M2... 리텐션율을 추적하여 코호트 분석을 수행합니다.",
    "schema": [
      {
        "table": "users",
        "columns": [
          "user_id",
          "signup_date"
        ]
      },
      {
        "table": "events",
        "columns": [
          "event_id",
          "user_id",
          "event_date"
        ]
      }
    ],
    "question": "2025년 각 가입 월별 코호트의 월별 리텐션율을 계산하세요.\n(M0 = 가입월, M1 = 가입 후 1개월, M2 = 가입 후 2개월...)",
    "hints": [],
    "answerQuery": "WITH signup_cohorts AS (\n    SELECT \n        user_id,\n        strftime('%Y-%m-01', signup_date) AS cohort_month\n    FROM users\n    WHERE signup_date >= '2025-01-01'\n      AND signup_date < '2026-01-01'\n),\nmonthly_active AS (\n    SELECT DISTINCT\n        strftime('%Y-%m-01', event_date) AS activity_month,\n        user_id\n    FROM events\n    WHERE event_date >= '2025-01-01'\n),\ncohort_activity AS (\n    SELECT \n        sc.cohort_month,\n        ma.activity_month,\n        COUNT(DISTINCT ma.user_id) AS active_users,\n        COUNT(DISTINCT sc.user_id) AS cohort_size,\n        CAST(strftime('%m', (julianday(ma.activity_month) - julianday(sc.cohort_month)) AS INTEGER)) AS months_since_signup\n    FROM signup_cohorts sc\n    LEFT JOIN monthly_active ma \n        ON sc.user_id = ma.user_id\n        AND ma.activity_month >= sc.cohort_month\n    GROUP BY sc.cohort_month, ma.activity_month\n)\nSELECT \n    cohort_month,\n    cohort_size,\n    months_since_signup AS month_number,\n    active_users,\n    ROUND(100.0 * active_users / cohort_size, 2) AS retention_pct\nFROM cohort_activity\nWHERE months_since_signup IS NOT NULL\nORDER BY cohort_month, months_since_signup;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM users\n",
    "explanation": "핵심 개념 - Cohort Analysis: 동일 시기 가입자 그룹 추적 - Retention Table: 리텐션 매트릭스 시각화 - `AGE()`: 날짜 간격 계산 - Pivot: 행을 열로 전환"
  },
  {
    "day": 29,
    "title": "복잡한 Moving Average (이동 평균선)",
    "difficulty": "advanced",
    "database": "ecommerce",
    "context": "쿠팡의 예측팀에서 \"7일/30일 이동 평균 매출\"을 계산합니다. 단기/장기 트렌드를 비교하여 매출 변화를 조기에 감지합니다.",
    "schema": [
      {
        "table": "orders",
        "columns": [
          "order_id",
          "order_date",
          "total_amount",
          "status"
        ]
      }
    ],
    "question": "2025년 1월 각 날짜의:\n- 일별 매출\n- 7일 이동 평균\n- 30일 이동 평균\n- 7일 평균과 30일 평균의 차이 (골든 크로스/데드 크로스 감지)\n를 계산하세요.",
    "hints": [],
    "answerQuery": "WITH daily_revenue AS (\n    SELECT \n        DATE(order_date) AS day,\n        SUM(total_amount) AS daily_sales\n    FROM orders\n    WHERE order_date >= '2024-12-01'  -- 30일 이동평균을 위해 더 많은 데이터 필요\n      AND order_date < '2025-02-01'\n      AND status = 'completed'\n    GROUP BY DATE(order_date)\n),\nmoving_averages AS (\n    SELECT \n        day,\n        daily_sales,\n        AVG(daily_sales) OVER (\n            ORDER BY day\n            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW\n        ) AS ma_7day,\n        AVG(daily_sales) OVER (\n            ORDER BY day\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS ma_30day\n    FROM daily_revenue\n)\nSELECT \n    day,\n    ROUND(daily_sales, 0) AS daily_sales,\n    ROUND(ma_7day, 0) AS ma_7,\n    ROUND(ma_30day, 0) AS ma_30,\n    ROUND(ma_7day - ma_30day, 0) AS ma_diff,\n    CASE \n        WHEN ma_7day > ma_30day THEN '상승 추세 (골든 크로스)'\n        WHEN ma_7day < ma_30day THEN '하락 추세 (데드 크로스)'\n        ELSE '중립'\n    END AS trend_signal,\n    LAG(ma_7day - ma_30day) OVER (ORDER BY day) AS prev_diff,\n    CASE \n        WHEN (ma_7day - ma_30day) > 0 \n             AND LAG(ma_7day - ma_30day) OVER (ORDER BY day) <= 0 \n        THEN '⚠️ 골든 크로스 발생'\n        WHEN (ma_7day - ma_30day) < 0 \n             AND LAG(ma_7day - ma_30day) OVER (ORDER BY day) >= 0 \n        THEN '⚠️ 데드 크로스 발생'\n        ELSE ''\n    END AS crossover_alert\nFROM moving_averages\nWHERE day >= '2025-01-01'  -- 2025년 1월만 출력\nORDER BY day;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM orders\n",
    "explanation": "핵심 개념 - Moving Average: 이동 평균선 - `ROWS BETWEEN N PRECEDING AND CURRENT ROW`: N+1일 평균 - 골든 크로스: 단기 > 장기 (상승 신호) - 데드 크로스: 단기 < 장기 (하락 신호)"
  },
  {
    "day": 30,
    "title": "종합 대시보드 쿼리 (All-in-One KPI)",
    "difficulty": "advanced",
    "database": "ecommerce",
    "context": "토스 커머스의 경영진이 요청한 \"월간 비즈니스 대시보드\"입니다. 핵심 KPI를 한 번에 조회하여 비즈니스 현황을 파악합니다.",
    "schema": [
      {
        "table": "users",
        "columns": [
          "user_id",
          "signup_date"
        ]
      },
      {
        "table": "orders",
        "columns": [
          "order_id",
          "user_id",
          "order_date",
          "total_amount",
          "status"
        ]
      },
      {
        "table": "order_items",
        "columns": [
          "order_item_id",
          "order_id",
          "product_id",
          "quantity",
          "item_price"
        ]
      }
    ],
    "question": "2025년 1월의 종합 KPI를 한 번에 계산하세요:\n1. 총 매출 (GMV)\n2. 주문 수\n3. 신규 가입자 수\n4. 활성 구매자 수 (Active Buyers)\n5. 객단가 (AOV)\n6. 재구매율 (Repeat Purchase Rate)\n7. 전월 대비 매출 증감률\n8. 주문당 평균 상품 수",
    "hints": [],
    "answerQuery": "WITH current_month AS (\n    SELECT \n        -- 1. GMV (Gross Merchandise Value)\n        SUM(total_amount) AS gmv,\n        \n        -- 2. 주문 수\n        COUNT(DISTINCT order_id) AS total_orders,\n        \n        -- 4. 활성 구매자 수\n        COUNT(DISTINCT user_id) AS active_buyers,\n        \n        -- 5. 객단가 (AOV = Average Order Value)\n        ROUND(AVG(total_amount), 0) AS aov\n    FROM orders\n    WHERE order_date >= '2025-01-01'\n      AND order_date < '2025-02-01'\n      AND status = 'completed'\n),\nprevious_month AS (\n    SELECT SUM(total_amount) AS prev_gmv\n    FROM orders\n    WHERE order_date >= '2024-12-01'\n      AND order_date < '2025-01-01'\n      AND status = 'completed'\n),\nnew_signups AS (\n    -- 3. 신규 가입자 수\n    SELECT COUNT(*) AS new_users\n    FROM users\n    WHERE signup_date >= '2025-01-01'\n      AND signup_date < '2025-02-01'\n),\nrepeat_customers AS (\n    -- 6. 재구매율\n    SELECT \n        COUNT(DISTINCT user_id) AS repeat_buyers\n    FROM orders\n    WHERE user_id IN (\n        SELECT user_id\n        FROM orders\n        WHERE order_date >= '2025-01-01'\n          AND order_date < '2025-02-01'\n          AND status = 'completed'\n        GROUP BY user_id\n        HAVING COUNT(*) >= 2\n    )\n),\nitems_per_order AS (\n    -- 8. 주문당 평균 상품 수\n    SELECT \n        AVG(item_count) AS avg_items_per_order\n    FROM (\n        SELECT \n            oi.order_id,\n            COUNT(*) AS item_count\n        FROM order_items oi\n        JOIN orders o ON oi.order_id = o.order_id\n        WHERE o.order_date >= '2025-01-01'\n          AND o.order_date < '2025-02-01'\n          AND o.status = 'completed'\n        GROUP BY oi.order_id\n    ) AS order_items_count\n)\nSELECT \n    '2025-01' AS period,\n    \n    -- 1. GMV\n    cm.gmv,\n    \n    -- 2. 주문 수\n    cm.total_orders,\n    \n    -- 3. 신규 가입자\n    ns.new_users,\n    \n    -- 4. 활성 구매자\n    cm.active_buyers,\n    \n    -- 5. 객단가\n    cm.aov,\n    \n    -- 6. 재구매율\n    ROUND(100.0 * rc.repeat_buyers / NULLIF(cm.active_buyers, 0), 2) AS repeat_rate_pct,\n    \n    -- 7. 전월 대비 매출 증감률\n    ROUND(100.0 * (cm.gmv - pm.prev_gmv) / NULLIF(pm.prev_gmv, 0), 2) AS gmv_growth_pct,\n    \n    -- 8. 주문당 평균 상품 수\n    ROUND(ipo.avg_items_per_order, 2) AS avg_items_per_order\n    \nFROM current_month cm\nCROSS JOIN previous_month pm\nCROSS JOIN new_signups ns\nCROSS JOIN repeat_customers rc\nCROSS JOIN items_per_order ipo;",
    "starterCode": "-- 여기에 SQL 쿼리를 작성하세요\nSELECT \n    \nFROM users\n",
    "explanation": "핵심 개념 - `CROSS JOIN`: 단일 행 테이블 결합 - 여러 CTE를 조합하여 종합 지표 생성 - 실무에서 자주 사용되는 대시보드 쿼리 패턴 출력 예시:"
  }
]